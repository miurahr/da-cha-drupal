<?php
/* $Id: url_profile.module,v 1.2 2006/12/15 21:53:59 alexb Exp $ */

/**
 * @file
 * Gather information about site and article URLs.
 * Sponsored by Development Seed.
 * 
 * @todo: url profile objects usually have the variable $url. this is misleading.
 * in the future: use $up for those objects, rename $url for object to $up and $url_str for url strings to $url.
 * 
 * @todo: in the past, we considered a URL profile as custom URL profile, if $up->criteria != "", now there is an
 * additional flag, that indicates, wether profile is custom: $up->custom - that allows for custom URL profiles without
 * criteria - make use of $up->custom instead of $up->criteria as test for custom profile consistent throughout code. 
 */

/*
Copyright (C) 2006 by Marcin Konicki <ahwayakchih@gmail.com>
Modified by: Aron Novak <aron@novaak.net>, Alex Barth alex developmentseed org
Create profiles for URLs. Depends on leech module.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY.

See the LICENSE file for more details.
*/

define('UP_EXPIRATION_VALIDURL', 604800);
define('UP_EXPIRATION_INVALIDURL', 86400);
define('PREG_HTML_REDIRECT', '/<meta[ \n]*http-equiv=["]*Refresh["]*[ \n]*content=["]*[0-9]*;( )*URL=([a-z:\/\/a-z.\/?=&%\1-9]*)["]*[ ]*[\n]*(\/)*>/i');
define('PREG_JSCRIPT_REDIRECT', '/<script.*>[=\t.a-z (){}<!"\-\n]*(document|window).location(\.href)*[ ]*=[ ]*"([\.:a-z\/]*)"/i');

define("UP_SHOW_LINK_IN_LINKS", 1);
define("UP_SHOW_LINK_INLINE", 2);

/**
 * Form for custom sources
 *
 * @param array $params if set, the default values are set to this
 * @return array The form
 */
function _url_profile_source_form($params = FALSE) {
  $form = array();
  $form['title'] = array('#title' => t('Title'),
  '#type' => 'textfield',
  '#default_value' => is_array($params) ? $params["title"] : '',
  '#description' => t('Title of URL profile'));
  $form['url_profile_manual_add'] = array('#title' => t('Rules'),
  '#type' => 'fieldset');
  $form['url_profile_manual_add']['url'] = array('#title' => t('URL'),
  '#type' => 'textfield',
  '#description' => t('Enter here the URL an item must originate from in order to become associated with this URL profile (e. g. "http://www.example.com")' ),
  '#default_value' => is_array($params) ? $params["url"] : 'http://');
  $form['url_profile_manual_add']['criteria'] = array('#title' => t('Condition'),
  '#type' => 'textfield',
  '#description' => t('Enter here a string that must occur in an item\'s URL in order to become associated with this URL profile (e. g. "friendID=1234567890")'),
  '#default_value' => is_array($params) ? $params["criteria"] : '');
  if (isset($params["upid"])) {
    $form['url_profile_manual_add']['upid'] =  array('#type' => 'hidden', '#value' => $params["upid"]);
  }
  $form['submit'] = array('#type' => 'submit',
  '#value' => t('Submit'),
  '#description' => t('All URL profiles will be updated. This might take a while, do not hit refresh in the meantime.'));
  return $form;
}

/**
 * Implementation of hook_help().
 */
function url_profile_help($section) {
  switch ($section) {
    case 'admin/help#url_profile':
    return t('The url_profile module deduces base URLs from leech feed item URLs.
                This is particularly helpful if you subscribe to keyword feeds from sites such as http://news.google.com
                and you want to know where the articles coming in from it do actually come from. Also check out the plug in modules
                url_profile_alexa and url_profile_technorati for retrieving Alexa and Technorati data for URLs.');
    case 'admin/modules#description':
    return t('Deduces base URL from leech feed item URLs. <em>Requires leech module.</em>');
  }
}

/**
 * Implementation of hook_perm().
 */
function url_profile_perm() {
  return array('administer url profiles', 'view url profiles');
}

/**
 * Implementation of hook_menu()
 */
function url_profile_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'url_profile',
    'title' => t('URL profile'),
    'callback' => 'url_profile_page',
    'access' => user_access('view url profiles') );
    $items[] = array('path' => 'url_profile/delete',
    'title' => t('URL profile'),
    'callback' => 'url_profile_manual_delete',
    'access' => user_access('administer url profiles'),
    'type' => MENU_CALLBACK);
    $items[] = array('path' => 'url_profile/autocomplete',
    'title' => t('url autocomplete'),
    'callback' => 'url_profile_autocomplete',
    'access' => user_access('view url profiles'),
    'type' => MENU_CALLBACK);
    $items[] = array('path' => 'url_profile/add_item',
    'title' => t('Create custom URL profile'),
    'callback' => 'url_profile_manual_add',
    'access' => user_access('administer url profiles'));
    $items[] = array('path' => 'url_profile/custom',
    'title' => t('Manage custom URL profile'),
    'callback' => 'url_profile_page_list_manual',
    'access' => user_access('administer url profiles'));
  }
  else {
    $items[] = array('path' => 'url_profile/cron_now',
    'callback' => 'url_profile_cron',
    'type' => MENU_CALLBACK);
    if (arg(0) == 'url_profile' && is_numeric(arg(1))) {
      $up = url_profile_load(arg(1));
      if ($up->criteria != "") {
        $items[] = array('path' => 'url_profile/'. arg(1), 'title' => t('view'),
        'callback' => 'url_profile_page',
        'access' => user_access('view url profiles'),
        'type' => MENU_CALLBACK);
        $items[] = array('path' => 'url_profile/'. arg(1).'/view', 'title' => t('view'),
        'weight' => -10,
        'type' => MENU_DEFAULT_LOCAL_TASK);
        $items[] = array('path' => 'url_profile/'. arg(1) .'/edit', 'title' => t('edit'),
        'callback' => 'url_profile_page',
        'access' => user_access('administer url profiles'),
        'weight' => 1,
        'type' => MENU_LOCAL_TASK);
        $items[] = array('path' => 'url_profile/'. arg(1) .'/delete', 'title' => t('delete'),
        'callback' => 'url_profile_page',
        'access' => user_access('administer url profiles'),
        'weight' => 3,
        'type' => MENU_LOCAL_TASK);
      }
    }
  }

  return $items;
}

/**
 * prints view of latest cron times
 */
function _url_profile_cron_times_view($crontimes = array()){
  $output = '<div class="crontimes">';

  $last_time = 0;
  if (count($crontimes) > 1) {
    $output .= '<div><strong>'.t('Latest').' '.(count($crontimes)-1).' '.t('cron runs').'</strong></div>';
    foreach ($crontimes as $t) {
      if ($last_time != 0) {
        $output .= '<div>';
        $output .= format_date($t, 'large');
        $output .= ', '.t('after').' '.format_interval($t-$last_time);
        $output .= '</div>';
      }
      $last_time = $t;
    }
  }
  else {
    $output .= '<div><strong>'.t('Latest').' '.t('cron runs').'</strong></div>';
    $output .= t('Cron has not been run.');
  }
  $output .= '</div>';

  return $output;
}

/**
 * Implementation of hook_settings().
 */
function url_profile_settings() {
  $form = array();

  $form['cron'] = array(
  '#type' => 'fieldset',
  '#title' => t('Cron settings'),
  '#tree' => FALSE,
  );
  // list last n times cron was called
  $form['cron']['url_profile_cron_overview'] = array(
  '#type' => 'markup',
  '#value' => _url_profile_cron_times_view(variable_get('url_profile_cron_times', array())),
  );
  // how many leeches to update at one cron run
  $upid_count = drupal_map_assoc(array(1, 2, 3, 4, 5, 10, 15, 20, 25, 50, 100));
  $upid_count['0'] = t('None');
  $upid_count['10000000'] = t('All');
  $form['cron']['url_profile_cron_count'] = array(
  '#type' => 'select',
  '#title' => t('Update count'),
  '#default_value' => variable_get('url_profile_cron_count', 5),
  '#options' => $upid_count,
  '#description' => t('Select how many url profiles can be updated at one cron run.'));
  $period = drupal_map_assoc(array(1, 900, 1800, 3600, 7200, 10800, 21600, 32400, 43200, 64800, 86400, 172800, 259200, 604800, 1209600, 2419200), 'format_interval');
  $period[0] = t('always');
  $form['cron']['url_profile_expiration_invalidurl'] = array(
  '#type' => 'select',
  '#title' => t('Update interval for invalid URL profiles'),
  '#default_value' => variable_get('url_profile_expiration_invalidurl', UP_EXPIRATION_INVALIDURL),
  '#options' => $period,
  '#description' => t('Time after which a failed URL profiling process will attempted again.'));
  $form['cron']['url_profile_expiration_validurl'] = array(
  '#type' => 'select',
  '#title' => t('Update interval for valid URL profiles'),
  '#default_value' => variable_get('url_profile_expiration_validurl', UP_EXPIRATION_VALIDURL),
  '#options' => $period,
  '#description' => t('Time after which a valid URL profile will get checked for updates.'));

  $form['display'] = array(
  '#type' => 'fieldset',
  '#title' => t('Display settings'),
  '#tree' => FALSE,
  );
  $form['display']['url_profile_show_link'] = array(
  '#type' => 'select',
  '#title' => t('Show link to URL profile with each leech feed item'),
  '#default_value' => variable_get('url_profile_show_link', 0),
  '#options' => array(0 => t('Don\'t show'),
  UP_SHOW_LINK_IN_LINKS => t('In links list'),
  UP_SHOW_LINK_INLINE => t('Inline in body/teaser')),
  '#description' => t('If "In links list" selected, Leech News will show link to source feed on each item in links list, if "Inline in body/teaser" selected, it will show this link in the feed item\'s body.'));

  $form['display']['url_profile_autoload'] = array(
  '#type' => 'checkbox',
  '#title' => t('Automatically load URL profiles data'),
  '#default_value' => variable_get('url_profile_autoload', 1),
  '#description' => t('If autoload is enabled, module will load profile data for each URL listed with node whenever that node is being loaded from database. This is required for showing URL profile information on nodes.'));

  $form['url_profile_addons'] = array(
  '#type' => 'fieldset',
  '#title' => t('Addons'),
  '#tree' => TRUE
  );
  $list = variable_get('url_profile_addons', array());
  $form['url_profile_addons']['weight'] = array(
  '#value' => t('Order, in which add on modules get called - modules that provide URLs should go first.'));
  foreach (module_implements('url_profile') as $name) {
    $form['url_profile_addons']['weight'][$name] = array(
    '#type' => 'select',
    '#title' => $name,
    '#options' => array('-10' => -10, '-9' => -9, '-8' => -8, '-7' => -7, '-6' => -6, '-5' => -5, '-4' => -4, '-3' => -3, '-2' => -2, '-1' => -1, '0' => 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
    '#default_value' => $list['weight'][$name] ? $list['weight'][$name] : 10,
    '#weight' => $list['weight'][$name] ? $list['weight'][$name] : 10,
    );
  }
  return $form;
}

/**
 * Implementation of hook_nodeapi().
 */
function url_profile_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'insert':
    case 'update':
    _url_profile_node_save($node);
    break;

    case 'delete':
    // Remove URLs and gathered data? Or just remove link between URLs and node?
    // If remove URLs too then we have to first check if no other nodes are connected with those URLs.
    _url_profile_node_delete($node);
    break;

    case 'load':
    if (variable_get('url_profile_autoload', 1)) {
      _url_profile_node_load($node);
    }
    break;
    case 'view':
    if (variable_get('url_profile_show_link', 0) == UP_SHOW_LINK_INLINE) {
      if (isset($node->url_profiles)) {
        $themed_links = theme('url_profile_inline_link', $node->url_profiles);
        if (isset($node->teaser)) {
          $node->teaser = $themed_links.$node->teaser;
        }
        if (isset($node->body)) {
          $node->body = $themed_links.$node->body;
        }
      }
    }
    break;

    default:
    break;
  }
}


/**
 * RSS auto-discovery
 * author: Keith Devens (http://keithdevens.com/weblog/archive/2002/Jun/03/RSSAuto-DiscoveryPHP)
 * @param $html
 *   raw HTML source
 * @param $location
 *   the location you got it from
 * @return
 *   The RSS feed link
 */
function _get_rss_location($html, $location) {
  if (!$html or !$location) {
    return FALSE;
  }
  else {
    //search through the HTML, save all <link> tags
    // and store each link's attributes in an associative array
    preg_match_all('/<link\s+(.*?)\s*\/?>/si', $html, $matches);
    $links = $matches[1];
    $final_links = array();
    $link_count = count($links);
    for ($n = 0; $n < $link_count; $n++){
      $attributes = preg_split('/\s+/s', $links[$n]);
      foreach ($attributes as $attribute) {
        $att = preg_split('/\s*=\s*/s', $attribute, 2);
        if (isset($att[1])) {
          $att[1] = preg_replace('/([\'"]?)(.*)\1/', '$2', $att[1]);
          $final_link[strtolower($att[0])] = $att[1];
        }
      }
      $final_links[$n] = $final_link;
    }
    //now figure out which one points to the RSS file
    for ($n = 0; $n < $link_count; $n++) {
      if (strtolower($final_links[$n]['rel']) == 'alternate'){
        if (strtolower($final_links[$n]['type']) == 'application/rss+xml'){
          $href = $final_links[$n]['href'];
        }
        if (!$href and strtolower($final_links[$n]['type']) == 'text/xml') {
          //kludge to make the first version of this still work
          $href = $final_links[$n]['href'];
        }
        if ($href) {
          if (strstr($href, "http://") !== FALSE) { #if it's absolute
            $full_url = $href;
          }
          else if (substr($href, 0, 2) == '//') {
            $full_url = 'http:'.$href;
          }
          else { //otherwise, 'absolutize' it
            $url_parts = parse_url($location);
            //only made it work for http:// links. Any problem with this?
            $full_url = "http://$url_parts[host]";
            if (isset($url_parts['port'])){
              $full_url .= ":$url_parts[port]";
            }
            if ($href{0} != '/'){ //it's a relative link on the domain
              $full_url .= dirname($url_parts['path']);
              if (substr($full_url, -1) != '/') {
                //if the last character isn't a '/', add it
                $full_url .= '/';
              }
            }
            $full_url .= $href;
          }
          return $full_url;
        }
      }
    }
    return FALSE;
  }
}


/**
 * Implementation of hook_cron().
 */
function url_profile_cron() {

  $crontimes = variable_get('url_profile_cron_times', array());
  $crontimes[] = time();
  if (count($crontimes) > 6) {
    array_shift($crontimes);
  }
  variable_set('url_profile_cron_times', $crontimes);

  $result = db_query_range('SELECT upid
                            FROM {url_profile_url} 
                            WHERE (checked <= %d AND valid != 1)
                            OR (checked <= %d AND valid = 1)
                            ORDER BY checked ASC', 
                            (time()-variable_get('url_profile_expiration_invalidurl', UP_EXPIRATION_INVALIDURL)),
                            (time()-variable_get('url_profile_expiration_validurl', UP_EXPIRATION_VALIDURL)),
                            0,
                            variable_get('url_profile_cron_count', 5)
                            );
                            if (db_num_rows($result) < 1) {
                              return;
                            }
                            $args = func_get_args();
                            while ($temp = db_fetch_object($result)) {
                              $url = url_profile_load($temp->upid);
                              url_profile_check($url);
                            }
}

/**
 * Create a form for editing an existing source profile
 *
 * @param integer $upid Url profile ID
 * @return string The HTML form
 */
function url_profile_manual_edit($upid) {
  $result = db_query("SELECT * FROM {url_profile_url} WHERE upid = %d", $upid);
  $source = db_fetch_array($result);
  $form = _url_profile_source_form($source);
  drupal_set_title(t('Edit custom URL profile'));
  return drupal_get_form('url_profile_manual_edit', $form);

}

/**
 * lists only custom URL profiles
 */
function url_profile_page_list_manual() {
  return url_profile_page_list('custom');
}

/**
 * Create a list of URL profiles
 *
 * @return string HTML content
 */
function url_profile_page_list($action = '') {
  if ($action == 'custom') {
    $result = db_query("SELECT * FROM {url_profile_url} WHERE criteria != ''");
  }
  else {
    $result = db_query("SELECT * FROM {url_profile_url}");
  }
  while ($source = db_fetch_object($result)) {
    if (strlen($source->criteria) > 0) {
      $sources[] = array(l($source->title.'*', "url_profile/{$source->upid}"), $source->url, $source->criteria, l(t("Edit"), "url_profile/{$source->upid}/edit") . ' | ' . l(t("Delete"), "url_profile/delete/" . $source->upid));
    }
    else {
      $sources[] = array(l($source->title, "url_profile/{$source->upid}"), $source->url, $source->criteria);
    }
  }
  if (!is_array($sources)) {
    if ($action == 'custom') {
      return t('No custom URL profiles defined.');
    }
    else {
      return t('No URL profiles available.');
    }
  }
  return theme_table(array(t('Title'), t('Source URL'), t('Condition'), t('Operations')), $sources, array());
}

/**
 * Process editing an existing source profile modification
 *
 * @param string $form_id Drupal form ID
 * @param string $form_values Values of form
 */
function url_profile_manual_edit_submit($form_id, $form_values) {
  db_query("UPDATE {url_profile_url} SET title = '%s', criteria = '%s', url = '%s' WHERE upid =  %d",
  $form_values['title'],
  $form_values['criteria'],
  $form_values['url'],
  $form_values['upid']);
  drupal_set_message($form_values['title'] . t(" custom URL profile updated."));
}

/**
 * Delete an existing source profile
 *
 * @param integer $upid Url profile ID
 * @return string The overview list of the source profiles
 */
function url_profile_manual_delete($upid) {
  $url = url_profile_load($upid);
  url_profile_delete($url);
  drupal_set_message(t("URL Profile"). " " . $url->url . " " .t("deleted."));
  return url_profile_page_list(true);

}

/**
 * Custom definition of source url profiles form
 *
 * @return string The created form
 */
function url_profile_manual_add() {
  return drupal_get_form('url_profile_manual_add', _url_profile_source_form());
}

function url_profile_manual_add_validate($form_id, $form_values) {
  $url = trim($form_values['url'], "/");
  $title = trim(check_plain($form_values['title']));
  $criteria = trim($form_values['criteria']);

  if (url_profile_load($url, $criteria)){
    form_set_error('', "URL profile with this condition already exists.");
  }
  if ($criteria == ""){
    form_set_error('', "Enter condition.", 'error');
  }
  if ( ($url == "") || ($url == "http://")){
    form_set_error('', "Enter valid URL.", 'error');
  }
}

/**
 * Process the custom definition of source url profiles form
 *
 * @param string $form_id Drupal form ID
 * @param array $form_values Values of form
 */
function url_profile_manual_add_submit($form_id, $form_values) {
  $url = trim($form_values['url'], "/");
  $title = trim(check_plain($form_values['title']));
  $criteria = trim($form_values['criteria']);

  url_profile_save($url, time(), 1, $criteria, $title);

  // associate all children
  _url_profile_associate_children($url, TRUE);

  drupal_set_message(t('The custom source URL profile was created successfully.'));
}


/**
 * Menu callback; Present profile of URL
 */
function url_profile_page($upid = NULL, $op = 'view') {
  if (!is_numeric($upid)) {
    if (is_numeric(arg(1))) {
      $upid = arg(1);
      $op = arg(2);
    }
    else {
      return url_profile_page_list();
    }
  }

  $url = url_profile_load($upid);

  if (!$url) {
    return drupal_not_found();
  }

  if (!user_access('view url profiles')) {
    return drupal_access_denied();
  }

  switch ($op) {

    case 'edit':
    if (user_access('administer url profiles')) {
      return url_profile_manual_edit($url->upid);
    }
    else {
      return drupal_access_denied();
    }
    break;

    case 'check':
    if (user_access('view url profiles')) {
      $url->checked = 0;
      url_profile_check($url, TRUE);
      _url_profile_associate_children($url, TRUE);
      drupal_goto('url_profile/'. $url->upid);
    }
    else {
      drupal_access_denied();
    }
    break;

    case 'delete':
    if (user_access('administer url profiles')) {
      url_profile_delete($url);
      if ($_GET['destination']){
        drupal_goto($_GET['destination']);
      }
      else {
        drupal_goto('admin/url_profile');
      }
    }
    else {
      drupal_access_denied();
    }
    break;
    /*
    case 'nodes':
    case 'list':
    return url_profile_list_node($url);
    break;
    */
    case 'view':
    default:
    return _url_profile_page($url, 'full');
  }
}

/**
 * theme function for inline presentation of links to url profile page
 */
function theme_url_profile_inline_link($url_profiles) {
  $links = array();
  foreach ($url_profiles as $up) {
    if ($up->checked != 0) {
      $markup = $up->criteria == "" ? "" : "*";
      $links[] = l($up->title.$markup, "url_profile/{$up->upid}", array('title' => t('View all articles from this source')));
    }
  }
  if (count($links) == 0) {
    $links[] = t('not profiled yet');
  }
  return '<div class="link url_profile">'.t('URL profile').": ".implode(', ', $links).'</div>';
}

/**
 * url profile output page
 */
function _url_profile_page(&$url, $display = 'medium') {
  static $css_done = FALSE;
  if (!$css_done) {
    $css_done = TRUE;
    theme_add_style(drupal_get_path('module', 'url_profile').'/url_profile.css');
  }

  $output_arr = array();
  
  $output_arr['title'] = check_plain($url->title).$markup;
  
  if ($url->criteria != "") {
    $output_arr['customcriteria'] = t("* Custom URL profile. Lists all items coming from")." \"".$url->url."\", ".t("URL containing")." \"". $url->criteria."\"";
  }

  $output_arr['url'] = $url->url;

  $is_checked = ($url->checked == 0 && $url->source_url == 0);
  if ($is_checked) {
    $output_arr['date'] = "<label>". t('Updated') .":</label> ". t("Not checked yet.");
  }
  else {
    $output_arr['date'] = "<label>". t('Updated') .":</label> ". format_interval(time()-$url->checked)." ".t('ago');
  }

  $output_arr['nodes'] .= $url->child_nodes;

  if (user_access('administer url profiles')) {
    $links = array();
    $links[] = l(t('refresh'), 'url_profile/'. $url->upid .'/check', null, 'destination='.$_GET['q']);
    // todo: make a confirm page for deleting sources
    $output_arr['links'] .= theme('links', $links);
  }

  // invoke other modules
  $output_arr['addons'] = url_profile_invoke($url, 'view', $display);


  // show associated nodes
  $result = pager_query('SELECT n.nid
                         FROM {node} n
                         JOIN {url_profile_node} p ON p.nid = n.nid
                         JOIN {url_profile_url} u ON u.upid = p.upid 
                         WHERE u.upid = %d
                         ORDER BY n.sticky DESC, n.created DESC',                          
  variable_get('default_nodes_main', 10), 0, NULL, $url->upid);
  if (db_num_rows($result) > 0) {
    while ($temp = db_fetch_object($result)) {
      $output .= node_view(node_load($temp->nid), 1);
    }
    $output .= theme('pager', NULL, variable_get('default_nodes_main', 10), 100);
  }
  else {
    $output .= t('There are currently no posts associated with this URL profile.');
  }
  $output_arr['nodelist'] = $output;

  $markup = $url->criteria == "" ? "" : "*";
  drupal_set_title(t('URL profile'));

  return theme('url_profile_page', $output_arr, $display);
}

/**
 * overrideable theming function, used in _url_profile_page()
 */
function theme_url_profile_page($output_arr, $display = 'medium'){
  $output  = "<div class=\"url_profile $display\">";
  $output .= '<div class="head">';
  $output .= '<H2>'.$output_arr['title'].'</H2>';
  $output .= '<div class ="url">'.l($output_arr['url'], $output_arr['url'], array('target' => '_'.$output_arr['url'])).'</div>';
  $output .= '<div class ="date">'.$output_arr['date'].' '.$output_arr['links'].'</div>';
  $output .= '<div class ="posts">'.t('Posts #').' '.$output_arr['nodes'].'</div>';
  $output .= implode(' ',$output_arr['addons']);
  $output .= '</div>';
  $output .= $output_arr['nodelist'];
  $output .= "</div>";
  return $output;
}

/**
 * Retrieve a pipe delimited string of autocomplete suggestions for existing URLs
 */
function url_profile_autocomplete($string) {
  $matches = array();
  $result = db_query_range("SELECT url FROM {url_profile_url} WHERE LOWER(url) LIKE LOWER('%s%%')", $string, 0, 10);
  while ($temp = db_fetch_object($result)) {
    $matches[$temp->url] = check_plain($temp->url);
  }
  print drupal_to_js($matches);
  exit();
}


/**
 * Invoke a hook_url_profile() operation in all modules.
 */
function url_profile_invoke(&$url, $op, $arg = NULL) {
  // TODO: write documentation? ;] For now here's what modules should return
  /*
  $op == 'list'
  get list of urls "attached" to node, which should be profiled.
  $url in this case is reference to node object.
  return array of url strings.

  $op == 'list_matches'
  get list of urls, that match the $url->url and $url->criteria of a given URL profile.
  return array of objects
  Array(
  [0] => Object (
  [nid] => <nid>,
  [url] => <url string>
  )
  ...
  )

  $op == 'load'
  load url data from database.
  no return value, operate on object passed by reference.

  $op == 'insert'
  save new url data to database.
  no return value, operate on object passed by reference.

  $op == 'update'
  save updated url data to database.
  no return value, operate on object passed by reference.

  $op == 'delete'
  delete url data to database.
  no return value, operate on object passed by reference.

  $op == 'check'
  download info from other sites, check parent url, etc..
  no return value, operate on object passed by reference.

  $op == 'view'
  return html content.
  */
  static $list;
  if (!is_array($list)) {
    $temp = variable_get('url_profile_addons', array());
    foreach (module_implements('url_profile') as $name) {
      $list[$name] = $temp['weight'][$name] ? $temp['weight'][$name] : 100;
    }
    asort($list);
  }

  $return = array();
  foreach ($list as $name => $weight) {
    $function = $name .'_url_profile';
    $result = $function($url, $op, $arg);
    if (isset($result) && is_array($result)) {
      $return = array_merge($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}


/**
 * Implementation of hook_link().
 */
function url_profile_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();

  if (variable_get('url_profile_show_link', 0) == UP_SHOW_LINK_IN_LINKS) {
    if ($type == 'node' && $node != NULL) {
      // todo: make type settting a user variable
      if (isset($node->url_profiles)) {
        if ( user_access("view url profiles") ) {
          foreach ($node->url_profiles as $url) {
            $links[] = t('Source').": ".l($url->title, "url_profile/{$url->upid}", array('title' => t('View all articles from this source')))." ";
          }
        }
      }
    }
  }
  return $links;
}

/**
 * Get list of URLs to be profiled.
 */
function url_profile_list(&$node) {
  return array_unique(url_profile_invoke($node, 'list'));
}

/**
 * Get list of URLs matching given URL
 */
function url_profile_list_matches($url) {
  return url_profile_invoke($url, 'list_matches');
}

/**
 * Load url profile object.
 */
function url_profile_load($upid, $criteria = "", $custom = false) {
  static $urls;

  if ($criteria != "") {
    $custom = true;
  }
  
  if (!is_array($urls)) {
    $urls = array();
  }

  if (is_numeric($upid)) {
    if (isset($urls[$upid])) {
      return $urls[$upid];
    }
    $result = db_query('SELECT * FROM {url_profile_url} WHERE upid = %d', $upid);
  }
  else if (is_string($upid)) {
    foreach ($urls as $id => $url) {
      if (($url->url == $upid) && ($url->criteria == $criteria)) {
        return $url;
      }
    }
    $result = db_query('SELECT * FROM {url_profile_url} WHERE url = \'%s\' AND criteria = "%s" AND custom = %d', $upid, $criteria, $custom);
  }

  if ($result) {
    $url = db_fetch_object($result);
    if ($url && $url->url) {
      // Let other modules prepare their info
      url_profile_invoke($url, 'load');
      $urls[$upid] = $url;
      return $url;
    }
  }

  return NULL;
}

/**
 * Save url profile object.
 * 
 * Overrides existing url_profile objects, if url string is equal.
 * 
 * pass in timestamp for $checked, to mark url profile last checked,
 * pass in $valid = 0, if you want to set url_profile invalid
 */
function url_profile_save(&$url, $checked = NULL, $valid = NULL, $criteria = "", $title = "", $custom = false) {

  if (is_string($url)) {
    $url = trim($url, '/');
    $temp = url_profile_load($url, $criteria, $custom);

    // create new object, if it does not exist yet.
    if (!$temp) {
      $temp = new StdClass();
      $temp->url = $url;
      $temp->checked = 0;
      $temp->valid = 0;
      $temp->criteria = $criteria;
      $temp->title = $title;
    }
    $url = $temp;
  }

  // take over function arguments, if some are defined
  // somehow, there is problems, if url_profile_save($url) is called
  // todo: actually, if an object is passed in, all optional arguments should be ignored
  $url->checked = ($checked !== NULL) ? $checked : $url->checked;
  $url->valid = ($valid !== NULL) ? $valid : $url->valid;

  $url->custom = $custom;
  if ($criteria != "") {
    $url->custom = true;
  }

  if (!$url->url || strlen($url->url) < 4) {
    return $url;
  }
  else {
    $url->url = trim($url->url, '/');
  }

  if (!$url->upid) {
    $url->upid = db_next_id('{url_profile_url}_upid');

    db_query('INSERT INTO {url_profile_url} (upid, url, checked, valid, created, custom, criteria, title) VALUES (%d, \'%s\', %d, %d, %d, %d, \'%s\', \'%s\')', $url->upid, $url->url, $url->checked, $url->valid, time(), $url->custom, $url->criteria, $url->title);
    url_profile_invoke($url, 'insert');
  }
  else {
    db_query("UPDATE {url_profile_url} SET url = '%s', checked = %d, valid = %d, custom = %d, criteria = '%s', title = '%s' WHERE upid = %d", $url->url, $url->checked, $url->valid, $url->custom, $url->criteria, $url->title, $url->upid);
    db_query('UPDATE {url_profile_url} uu SET uu.child_nodes = (SELECT COUNT(*)
                                                                FROM {url_profile_node} un 
                                                                WHERE un.upid = %d
                                                               ) 
              WHERE uu.upid = %d', $url->upid, $url->upid);
    url_profile_invoke($url, 'update');
  }

  return $url;
}

/**
 * Delete url profile object.
 */
function url_profile_delete(&$url) {

  url_profile_invoke($url, 'delete');
  db_query('DELETE FROM {url_profile_node} WHERE upid = %d', $url->upid);
  db_query('DELETE FROM {url_profile_url} WHERE upid = %d AND criteria = \'%s\'', $url->upid, $url->criteria);
}

/**
 * takes a url and checks, wether it points to an existing page,
 * optionally follows redirects. 
 * 
 * 200 ... OK
 * 301 ... Permanent Redirect
 * 302 ... Found
 * 307 ... Temporary Redirect
 * 
 *
 * @param string or url_profile object $url
 */
function _url_profile_validate($url, $followredirects = TRUE, $forcefullcheck = FALSE) {
  if (is_object($url)){
    $url_str = $url->url;
  }
  else {
    $url_str = $url;
  }
  $url_str = trim($url_str, "/");

  // static cache
  static $urlcache;

  /**
   * 1) if URL was validated in this page load, return the cached version
   */
  if (is_array($urlcache)) {
    if (isset($urlcache[$url_str])){
      return $urlcache[$url_str];
    }
  }


  /**
   * 2) IF a valid entry for $url is present in DB and if it is not older than UP_EXPIRATION_VALIDURL 
   * in the case of a valid URL (found) and UP_EXPIRATION_INVALIDURL in the case of an invalid URL (not found) 
   * return the result in the DB
  */ 
  if (!$forcefullcheck) {
    $result = db_query("SELECT upid, checked, valid FROM url_profile_url WHERE url = '%s' AND title = ''", $url_str);

    while ($up = db_fetch_object($result)) {
      // todo: actually, there should be NO multiple entries with one and the same url
      // - what are we going to do with custom url rules?
      if ((time() - $up->checked) < variable_get('url_profile_expiration_validurl', UP_EXPIRATION_VALIDURL)) {
        if ($up->valid == 1){
          $urlcache[$url_str] = url_profile_load($up->upid);
          return $urlcache[$url_str];
        }
        if ((time() - $up->checked) < variable_get('url_profile_expiration_invalidurl', UP_EXPIRATION_INVALIDURL)) {
          $urlcache[$url_str] = FALSE;
          return $urlcache[$url_str];
        }
      }
    }
  }

  /**
   * 3) if result wether in static cache nor in DB, or in DB, but expired, 
   * see, wether $url points to a valid resource on the internet. 
   * if yes, save the url as valid url_profile
   * if not, save it as INvalid url_profile
   * 
   * @todo: check, wether $followredirects works. 
   */

  for ($i = 0; $i < 3; $i++) {
    if ($i > 0) {
      usleep(200);
    }

    $connection = drupal_http_request($url_str, array(), 'GET', NULL, 0);
    if (isset($connection->error)) {
      watchdog('url_profile', t('HTTP request error %error', array('%error' => $connection->error)), WATCHDOG_ERROR );
    }

    // return url if page found
    if ($followredirects) {
      $codes = array(200);
    }
    else {
      $codes = array(200, 302, 307);
    }
    if (in_array($connection->code, $codes)) {
      $html_redirected = _url_profile_is_html_redirected($connection);
      if ($html_redirected !== FALSE && strlen($html_redirected) > 5) {
        $url = $html_redirected;
      }
      $urlcache[$url_str] = url_profile_save($url, time(), 1, "", $url_str);
      // invoke add-on-modules on validated url profile -
      // todo: move this, make call hierarchy of url_profile_check() and _url_profile_validate() cleaner
      url_profile_invoke($url, 'check');
      return $urlcache[$url_str];
    }

    // get location header on found and temporary redirect
    // drupal's function doesn't make "case-safe" names, so "location" != "Location" :(
    if ( ($connection->code == 302) || ($connection->code == 307) || ($connection->code == 301)) {
      foreach ($connection->headers as $name => $value) {
        if (strtolower($name) == 'location') {
          $urlcache[$url_str] = url_profile_save($value, time(), 1, "", $url_str);
          // invoke add-on-modules on validated url profile -
          // todo: move this, make call hierarchy of url_profile_check() and _url_profile_validate() cleaner
          url_profile_invoke($url, 'check');
          return $urlcache[$url_str];
        }
      }
    }
  }
  $urlcache[$url_str] = FALSE;
  url_profile_save($url, time(), 0);
  return FALSE;
}

/**
 * helper function for url_profile_check()
 * switches all nodes for a given array of url_profile to another url_profile
 */
function _url_profile_switch($upids_from, $upids_to) {

  // 1) get nodes associated with $upids_from
  $nids = array();
  $result = db_query('SELECT nid FROM {url_profile_node} WHERE upid IN ( %s )', implode(', ', $upids_from));
  while ($un = db_fetch_object($result)) {
    $nids[] = $un->nid;
  }

  // 2) delete all entries associating nodes to given $upids_from
  db_query('DELETE FROM {url_profile_node} WHERE upid IN ( %s )', implode(', ', $upids_from));

  // 3) associate nodes with the custom url profiles
  foreach ($upids_to as $upid) {
    foreach ($nids as $nid) {
      db_query('INSERT INTO {url_profile_node}(upid, nid) VALUES(%d, %d)', $upid, $nid);
    }
    db_query('UPDATE {url_profile_url} uu SET uu.child_nodes = (SELECT COUNT(*)
                                                                FROM {url_profile_node} un 
                                                                WHERE un.upid = %d
                                                               ) 
              WHERE uu.upid = %d', $upid, $upid);
  }
}

/**
 * Gather profile informations about URL.
 */
function url_profile_check($url, $forcefullcheck = FALSE) {

  // always use LAST http:// in URL
  $newurl = $url->url;
  $offset = 0;
  while ($offset = strpos($url->url, "http://", $offset+1)){
    $newurl = substr($url->url, $offset);
  }
  $offset = 0;
  while ($offset = strpos($url->url, "https://", $offset+1)){
    $newurl = substr($url->url, $offset);
  }
  $url->url = $newurl;

  // check if given URL is child of a custom url profile
  if ($upids = _url_profile_check_for_criteria($url->url)) {
    if (!in_array($url->upid, $upids)) {
      _url_profile_switch(array($url->upid), $upids);
    }
  }

  // find shortest part of url that is valid (reachable on the net)
  $u1 = parse_url($url->url);
  if (!isset($u1['scheme'])){
    // if url has no scheme, delete url
    url_profile_delete($url);
    return false;
  }

  $found = false;

  $scheme = $u1['scheme'] .'://';
  $hostandpath = str_replace($scheme, '', $url->url);

  // strip out query
  // isn't this the same as $hostandpath = $ul['host'].$ul['path'] ?
  if (($pos = strpos($hostandpath, '?')) > 0) {
    $hostandpath = substr($hostandpath, 0, $pos);
  }

  // try to find source url by going from base url to full url
  // once we find a valid URL we take it as a source URL

  // find subsequent next "/"
  $maxdepth = 10;
  $i = 0;
  $offset = 0;
  if (strpos($hostandpath, '/') === false) {
    $hostandpath .= '/';
  }
  while ($offset = strpos($hostandpath, '/', $offset+1)) {
    $i ++;
    if ($i > $maxdepth) {
      break;
    }
    $common = $scheme.substr($hostandpath, 0, $offset);

    // check, wether URL is valid
    if ($valid_up = _url_profile_validate($common, TRUE, $forcefullcheck)) {
      // switch to validated url profile, if it is different than current,
      // and if given URL profile is NOT a custom URL profile
      // else this is a "source" URL profile - like http://www.example.com
      if ((trim($url->url, "/") != trim($common, "/")) && ($url->criteria == "")) {
        _url_profile_switch(array($url->upid), array($valid_up->upid));
        url_profile_delete($url);
        $url = $valid_up;
      }
      return true;
    }
  }
  // we didn't find a source url - save url profile with new checked timestamp and mark invalid.
  url_profile_save($url, time(), 0);
  return false;
}

/**
 * Checking for meta tag redirecting in html source
 */
function _url_profile_is_html_redirected($connection) {

  if (!is_object($connection)) {
    return FALSE;
  }
  $result = $connection->data;
  preg_match_all(PREG_HTML_REDIRECT, $result, $matches_html);
  preg_match_all(PREG_JSCRIPT_REDIRECT, $result, $matches_js);
  if (is_string($matches_html[2][0]) && strlen($matches_html[2][0]) > 6) {
    return rtrim($matches_html[2][0], '"');
  }
  else if (is_string($matches_js[3][0]) && strlen($matches_js[3][0]) > 3) {
    // Maybe false positive
    return $matches_js[3][0];
  }
  else {
    // Not redirected or in a tricky javascript way - it's pretty rare
    return FALSE;
  }

}

/**
 * Private function; Load URL profiles attached to node
 */
function _url_profile_node_load(&$node) {
  $result = db_query('SELECT u.upid, n.nid FROM {url_profile_node} n LEFT JOIN {url_profile_url} u ON n.upid = u.upid WHERE n.nid = %d', $node->nid);
  while ($temp = db_fetch_object($result)) {
    if ($temp->nid == $node->nid) {
      $node->url_profiles[] = url_profile_load($temp->upid);
    }
  }
}

/**
 * Private function; Update connections between node and URLs, save new URLs to db
 */
function _url_profile_node_save(&$node) {

  $result = db_result(db_query('SELECT COUNT(*) FROM {url_profile_node} WHERE nid = %d', $node->nid));

  // it is assumed, that urls once in url_profile don't change anymore
  // if such an original link changes, the associated url profile would have to be deleted in order to create a new one
  if ($result) {
    return;
  }

  $urls = url_profile_list($node);

  if (count($urls) > 1) {
    // debug: actually, there shouldn't be more than one link on a node... if yes, we need to do sth here.
    watchdog('url_profile', t('More than one URL on node %d', array('%d'=>$node->nid)), WATCHDOG_ERROR, "node/".$node->nid);
  }
  foreach ($urls as $url) {
    $up = url_profile_save($url);
    if (isset($up->upid)) {
      db_query('INSERT INTO {url_profile_node} (upid, nid) VALUES (%d, %d)', $up->upid, $node->nid);
    }
    else {
      watchdog('url_profile', t('Error saving URL %url', array('%url'=>$url)), WATCHDOG_ERROR);
    }
  }
}

/**
 * Private function; Delete connections between node and URLs
 */
function _url_profile_node_delete(&$node) {
  // $upid = db_result(db_query('SELECT upid FROM {url_profile_node} WHERE nid = %d', $node->nid));
  db_query('DELETE FROM {url_profile_node} WHERE nid = %d', $node->nid);
}

/**
 * implementation of hook_block()
 */
function url_profile_block($op = 'list', $delta = O, $edit = array()){
  if ($op == 'view') {

    if (!user_access('view url profiles'))
    return $blocks;

    switch ($delta) {
      case 0:
      $blocks['subject'] = t("URL Profiles");
      $result = db_query('SELECT * FROM {url_profile_url} WHERE valid = 1 AND child_nodes >= %d OR criteria != "" ORDER BY title ASC', variable_get('url_profile_show_source_threshold', 1));
      while ($up = db_fetch_object($result)) {
        $url_profiles[] = $up;
      }
      $blocks['content'] = theme('url_profile_list', $url_profiles, _url_profile_show_source_threshold_form(), variable_get('url_profile_show_source_threshold', 1));
      break;
      default:
      break;
    }
  }
  elseif ($op == 'list') {
    // show and auto turn on blocks
    $blocks[0]['info'] = t('url_profile: List all source profiles');
  }
  return $blocks;
}

/**
 * creates a form for setting the threshold for sources on the block
 */
function _url_profile_show_source_threshold_form() {

  $form['url_profile_show_source_threshold'] = array(
  '#type' => 'select',
  '#title' => t('Posts / profile minimum'),
  '#default_value' => variable_get('url_profile_show_source_threshold', 1),
  '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 10, 15, 20, 25, 50, 100)),
  );

  $form['submit'] = array(
  '#type' => 'submit',
  '#value' => t('Submit'),
  );

  return drupal_get_form('url_profile_show_threshold', $form);
}

function url_profile_show_threshold_submit($form_id, $form) {
  if ($form_id == 'url_profile_show_threshold') {
    variable_set('url_profile_show_source_threshold', $form['url_profile_show_source_threshold']);
  }
}

/**
 * return a themed list of sources
 */
function theme_url_profile_list($url_profiles, $form, $threshold = NULL){

  if (!is_array($url_profiles)) {
    $output = t("No profiles available");
  }
  else {
    $output = "";

    if ($threshold != NULL) {
      $output .= "<div class=\"description\">";
      $output .= "All URL profiles with more than ".$threshold." child(ren) and custom URL profiles.";
      $output .= "</div>";
      $output .= "<ul class=\"sourcelist\">\n";
    }

    foreach ($url_profiles as $up){

      $title = strlen($up->title) > 30 ? substr($up->title, 0, 27)."..." : $up->title;
      if ($up->criteria == "") {
        $class = "";
        $mark = "";
      }
      else {
        $class ="custom";
        $mark = "*";
      }
      $output .= "  <li class=\"".$class."\">".l($title.$mark.' ('.$up->child_nodes.')', "url_profile/".$up->upid)."</li>\n";
    }
    $output .= "</ul>\n\n";
    $output .= '<div class="add url_profile">'.l('Create custom URL profile', 'url_profile/add_item', array('title' => 'Define a custom URL profile')).'</div>';
  }

  $output .= $form;

  return $output;
}

/**
 * Check if the given url is a child
 */
function _url_profile_is_child($url, $source_url, $source_criteria = "") {
  if (trim($source_criteria) != "") {
    if (strpos($url, $source_criteria) !== FALSE) {
      return TRUE;
    }
    return FALSE;
  }
  if (trim($url, "/") == trim($source_url, "/")) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Check the URL against the user-defined ruleset (for crazy urls, eg.)
 */
function _url_profile_check_for_criteria($url) {
  // don't care about valid bit -> custom url profiles can be based on invalid URLs
  $result = db_query('SELECT upid, url, criteria FROM {url_profile_url} uu
                      WHERE criteria != ""');

  if (is_object($url)) {
    $url = $url->url;
  }

  $matches = array();

  while ($profile = db_fetch_array($result)) {
    if (_url_profile_is_child($url, $profile['url'], $profile['criteria'])) {
      $matches[] = $profile['upid'];
    }
  }
  // We need multiple source - one article relation so need to do in this way
  if (count($matches) == 0) {
    return FALSE;
  }
  else {
    return $matches;
  }
}

/**
 * this function takes a source url profile object and associates urls in url_profile_url
 * as children
 */
function _url_profile_associate_children($up, $messages = FALSE) {

  if ($messages) {
    timer_start("up_assoc");
  }
  $list = url_profile_list_matches($up);
  
  $new = 0;
  $existing = 0;
  foreach ($list as $item) {
    if (_url_profile_is_child($item->url, $up->url, $up->criteria)) {
      if (db_result(db_query('SELECT * FROM {url_profile_node} WHERE upid = %d AND nid = %d', $up->upid, $up->nid))) {
        $existing++;
      }
      else {
        db_query('INSERT INTO {url_profile_node}(upid, nid) VALUES(%d, %d)', $up->upid, $item->nid);
        $new++;
      }
    }
  }
  db_query('UPDATE {url_profile_url} SET child_nodes = %d WHERE upid = %d', ($new+$existing), $up->upid);
  if ($messages) {
    drupal_set_message(t("Added ".$new." item(s) to this URL profile. (Before: %existing item(s)). (%time ms)", array('%existing' => $existing, '%time' => timer_read("up_assoc"))));
    timer_stop("up_assoc");
  }
}